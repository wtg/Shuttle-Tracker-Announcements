//
//  RefreshSequence.swift
//  Mapping Utility
//
//  Created by Gabriel Jacoby-Cooper on 10/9/23.
//

import OSLog

/// An asynchronous sequence that emits refresh signals for the Shuttle Tracker map.
///
/// The element type is ``RefreshType``, which is an enumeration that specifies whether the refresh was triggered manually (by the user) or automatically. Each type of refresh might be handled differently by code that awaits the emitted elements. Manual refreshes are generated when ``trigger()`` is invoked; automatic refreshes are generated by an internal timer with a configurable interval (see ``interval``).
@available(iOS 16, macOS 13, *)
actor RefreshSequence: AsyncSequence, AsyncIteratorProtocol {
	
	typealias Element = RefreshType
	
	private static let logger = Logger(subsystem: "com.gerzer.shuttletracker.mappingutility", category: "RefreshSequence")
	
	/// The interval between ``RefreshType/automatic`` refresh events.
	let interval: Duration
	
	/// The current automatic-refresh task.
	private lazy var productionTask = self.newProductionTask()
	
	/// Creates a refresh sequence.
	/// - Parameter interval: The interval between ``RefreshType/automatic`` refresh events.
	init(interval: Duration) {
		self.interval = interval
	}
	
	func next() async -> RefreshType? {
		do {
			try Task.checkCancellation()
		} catch {
			Self.logger.log(level: .error, "[\(#fileID):\(#line) \(#function, privacy: .public)] Refresh sequence canceled: \(error, privacy: .public)")
			return nil
		}
		do {
			self.productionTask = self.newProductionTask()
			return try await self.productionTask.value // Wait for the next automatic refresh event
		} catch is CancellationError {
			// Manual refresh events are signaled by canceling the automatic refresh production task.
			return .manual
		} catch {
			Self.logger.log(level: .error, "[\(#fileID):\(#line) \(#function, privacy: .public)] Refresh sequence production task failed: \(error, privacy: .public)")
			return nil
		}
	}
	
	/// Triggers a manual refresh event.
	func trigger() {
		// Manual refresh events are signaled by canceling the automatic refresh production task.
		self.productionTask.cancel()
	}
	
	/// Dispatches and returns a new task that emits an ``RefreshType/automatic`` refresh event after a particular interval.
	///
	/// The interval is specified by ``interval``.
	/// - Returns: The task.
	private func newProductionTask() -> Task<RefreshType, any Error> {
		return Task {
			try await Task.sleep(for: self.interval)
			return .automatic
		}
	}
	
	nonisolated func makeAsyncIterator() -> RefreshSequence {
		return self
	}
	
}

enum RefreshType {
	
	case manual, automatic
	
}
